---
import type { HTMLAttributes } from 'astro/types';
import { t } from '@lib/i18n';
import { ImgixParamsAuto, ImgixParamsFit, type ImgixParams } from '@lib/datocms/types';

interface ImageProps {
  alt?: string | null,
  title?: string | null,
  width?: number | null,
  height?: number | null,
  url: string,
  responsiveImage?: { 
    __typename?: 'ResponsiveImage',
    base64?: string | null
  } | null;
  focalPoint?: {
    x: number;
    y: number;
  } | null;
}

export interface Props extends HTMLAttributes<'figure'> {
  image: ImageProps;
  loading?: HTMLAttributes<'img'>['loading'];
  fetchpriority?: HTMLAttributes<'img'>['fetchpriority'];
  aspectRatio?: number;
  sizes?: HTMLAttributes<'img'>['sizes'];
  fit?: ImgixParamsFit;
  widths?: number[];
}

const defaultWidths = [1280, 960, 640, 320];

const {
  image,
  aspectRatio = (image.width && image.height) ? image.width / image.height : undefined,
  fit = ImgixParamsFit.Max,
  loading = 'lazy',
  fetchpriority = 'auto',
  sizes,
  widths = defaultWidths,
  ...props
} = Astro.props;
const altText = image.alt ? image.alt : ''; // default to empty string for accessibility
const imageUnavailableMessage = t('image_unavailable');

const getImgixQueryString = (params: ImgixParams) => {
  const w = params.w || Math.max(...widths);
  const stringifiedParams = Object.entries({
    w,
    ...aspectRatio
      ? { h: Math.round(w / aspectRatio) }
      : {},
    ...params,
  }).map(([key, value]) => [key, `${value}`]);
  return new URLSearchParams(stringifiedParams).toString();
};

const getImageSrc = (url: string, params: Record<string, number|string> = {}) => {
  const defaults: Record<string, number|string> = {
    auto: [
      ImgixParamsAuto.Compress, 
      ImgixParamsAuto.Format
    ].join(','),
    q: 80,
    w: Math.max(...widths),
    ...image.focalPoint
      ? { 'fp-x': image.focalPoint.x, 'fp-y': image.focalPoint.y }
      : {},
  };

  return new URL(`${url}?${getImgixQueryString({ ...defaults, ...params })}`).toString();
};

const getImageSrcSet = (url: string, widths: number[], params = {}) => {
  return widths.map((w) => {
    const src = getImageSrc(url, { w, fit, ...params });
    return `${src} ${w}w`;
  }).join(', ');
};
---
<image-component>
  <figure {...props}>
    {
      image.responsiveImage
        ? // bitmap images have Imgix generated props (responsiveImage.*):
        <img
          alt={ altText }
          loading={ loading }
          fetchpriority={ fetchpriority }
          sizes={ sizes }
          srcset={ getImageSrcSet(image.url, widths) }
          src={ getImageSrc(image.url) }
          width={ image.width }
          height={ image.height }
          style={{
            backgroundImage: `url(${image.responsiveImage.base64})`
          }}
          data-unavailable={ imageUnavailableMessage }
        />
        : // vector images do not have Imgix generated props, so using as is:
        <img
          alt={ altText }
          loading={ loading }
          fetchpriority={ fetchpriority }
          src={ image.url }
          width={ image.width }
          height={ image.height }
          data-unavailable={ imageUnavailableMessage }
        />
    }
    { image.title && (
      <figcaption>{ image.title }</figcaption>
    )}
  </figure>
</image-component>

<script src="./Image.client.ts"></script>

<style define:vars={{ 'aspect-ratio': aspectRatio || 'auto' }}>
/* functional styling */

img {
  display: block;
  max-width: 100%;
  height: auto;
  background-size: cover;
  aspect-ratio: var(--aspect-ratio);
}

/**
 * broken image styling, only applies when image fails to load
 * @see https://bitsofco.de/styling-broken-images/
 */
 img {
  position: relative;
  text-align: center;
 }
 img:after {
  content: attr(alt) " (" attr(data-unavailable) ")";
  display: block;
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  padding-top: calc(50% - 1em);
  background-color: #f1f1f1;
 }

 /* basic styling, can be removed */
 figcaption {
    text-align: center;
  }
</style>
